/*
 * Algebraic operations on the finite field GF(2^m)
 *
 * References:
 *
 * 1.	Erik De Win <erik.dewin@esat.kuleuven.ac.be> et alii:
 *		"A Fast Software Implementation for Arithmetic Operations in GF(2^n)",
 *		presented at Asiacrypt96 (preprint).
 *
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "ec_field.h"
#include "ec_param.h"
#include "ec_vlong.h"

#define BASE	(1U << GF_L)
#define TOGGLE	(BASE-1)

#if defined(PRECOMPUTE_TABLES)
static lunit *expt = NULL; /* index range is [0..(BASE-2)] */
static lunit *logt = NULL; /* index range is [1..(BASE-1)], but logt[0] is set to (BASE-1) */
#else

#ifdef __GNUC__
/* this has the wonderful side-effect of forcing this onto a separate page
 * boundary and reducing copies of these huge tables....
 */
#define TABLE_RELOC	__attribute__ ((section ("rodata")))
#else
#define TABLE_RELOC
#endif

#include "ecf_tables.c"
static const lunit *expt = ec_prebuilt_expt;
static const lunit *logt = ec_prebuilt_logt;
#undef TABLE_RELOC
#endif



int gf_init (void)
	/* initialize the library ---> MUST be called before any other gf-function */
{
#if defined(PRECOMPUTE_TABLES)
	ltemp root, i, j;

	if (logt != NULL && expt != NULL) {
		/* already initialized */
		return 0;
	}
	if (logt != NULL && expt == NULL ||
		logt == NULL && expt != NULL) {
		return 2; /* logic error: half initialized (?!) */
	}
	if ((logt = (lunit *) malloc (BASE * sizeof (lunit))) == NULL) {
		return 1; /* not enough memory */
	}
	if ((expt = (lunit *) malloc (BASE * sizeof (lunit))) == NULL) {
		free (logt); logt = NULL;
		return 1; /* not enough memory */
	}
	root = BASE | GF_RP;
	expt[0] = 1;
	for (i = 1; i < BASE; i++) { 
		j = (ltemp)expt[i-1] << 1;
		if (j & BASE) {
			j ^= root;
		}
		expt[i] = (lunit)j;
	}
	for (i = 0; i < TOGGLE; i++) {
		logt[expt[i]] = (lunit)i;
	}
	logt[0] = TOGGLE; /* a trick used by gf_multiply, gf_square, gf_addmul */

	puts("/* this file is automatically generated */");
	puts("#ifndef TABLE_RELOC");
	puts("#define TABLE_RELOC");
	puts("#endif");
	printf ("const lunit ec_prebuilt_logt[%u] TABLE_RELOC = {\n", BASE);
	for(i = 0; i < BASE; i += 16) {
		for (j = 0; j < 16; j++) {
			printf ("0x%03xU, ", logt[i+j]);
		}
		printf ("\n");
	}
	printf ("};\n\n");

	printf ("const lunit ec_prebuilt_expt[%u] TABLE_RELOC = {\n", BASE);
	for(i = 0; i < BASE; i += 16) {
		for (j = 0; j < 16; j++) {
			printf ("0x%03xU, ", expt[i+j]);
		}
		printf ("\n");
	}
	printf ("};\n\n");
#endif /* ?PRECOMPUTE_TABLES */

	return 0;
} /* gf_init */


void gf_quit (void)
	/* perform housekeeping for library termination */
{
#ifdef PRECOMPUTE_TABLES
	if (expt) {
		free (expt); expt = NULL;
	}
	if (logt) {
		free (logt); logt = NULL;
	}
#endif
} /* gf_quit */

int gf_equal (const gf_point p, const gf_point q)
	/* evaluates to 1 if p == q, otherwise 0 (or an error code) */
{
	assert (p != NULL);
	assert (q != NULL);
	return memcmp (p, q, p[0] + 1) ? 0 : 1;
} /* gf_equal */


void gf_clear (gf_point p)
	/* sets p := 0, clearing entirely the content of p */
{
	assert (p != NULL);
	memset (p, 0, sizeof (gf_point));
} /* gf_clear */


void gf_copy (gf_point p, const gf_point q)
	/* sets p := q */
{
	assert (p != NULL);
	assert (q != NULL);
	memcpy (p, q, (q[0] + 1) * sizeof (lunit));
} /* gf_copy */


void gf_add (gf_point p, const gf_point q, const gf_point r)
	/* sets p := q + r */
{
	ltemp i;

	assert (logt != NULL && expt != NULL);
	assert (p != NULL);
	assert (q != NULL);
	assert (r != NULL);
	if (q[0] > r[0]) {
		/* xor the the common-degree coefficients: */
		for (i = 1; i <= r[0]; i++) {
			p[i] = q[i] ^ r[i];
		}
		/* invariant: i == r[0] + 1 */
		memcpy (&p[i], &q[i], (q[0] - r[0]) * sizeof (lunit));
		/* deg(p) inherits the value of deg(q): */
		p[0] = q[0];
	} else if (q[0] < r[0]) {
		/* xor the the common-degree coefficients: */
		for (i = 1; i <= q[0]; i++) {
			p[i] = q[i] ^ r[i];
		}
		/* invariant: i == q[0] + 1 */
		memcpy (&p[i], &r[i], (r[0] - q[0]) * sizeof (lunit));
		/* deg(p) inherits the value of deg(r): */
		p[0] = r[0];
	} else { /* deg(q) == deg(r) */
		/* scan to determine deg(p): */
		for (i = q[0]; i > 0; i--) {
			if (q[i] ^ r[i]) {
				break;
			}
		}
		/* xor the the common-degree coefficients, if any is left: */
		for (p[0] = (lunit)i; i > 0; i--) {
			p[i] = q[i] ^ r[i];
		}
	}
} /* gf_add */


static void gf_reduce (gf_point p)
	/* reduces p mod the irreducible trinomial x^GF_K + x^GF_T + 1 */
{
	int i;

	for (i = p[0]; i > GF_K; i--) {
		p[i - GF_K] ^= p[i];
		p[i + GF_T - GF_K] ^= p[i];
		p[i] = 0;
	}
	if (p[0] > GF_K) {
		/* scan to update deg(p): */
		p[0] = GF_K;
		while (p[0] && p[p[0]]==0) {
			p[0]--;
		}
	}
} /* gf_reduce */


void gf_multiply (gf_point r, const gf_point p, const gf_point q)
	/* sets r := p * q mod (x^GF_K + x^GF_T + 1) */
{
	int i, j;
	ltemp x, log_pi, log_qj;
	lunit lg[GF_K + 2]; /* this table should be cleared after use */

	assert (logt != NULL && expt != NULL);
	assert (p != NULL);
	assert (q != NULL);
	assert (r != p);
	assert (r != q);
	if (p[0] && q[0]) {
		/* precompute logt[q[j]] to reduce table lookups: */
		for (j = q[0]; j; j--) {
			lg[j] = logt[q[j]];
		}
		/* perform multiplication: */
		gf_clear (r);
		for (i = p[0]; i; i--) {
			if ((log_pi = logt[p[i]]) != TOGGLE) { /* p[i] != 0 */
				for (j = q[0]; j; j--) {
					if ((log_qj = lg[j]) != TOGGLE) { /* q[j] != 0 */
					/*	r[i+j-1] ^= expt[(logt[p[i]] + logt[q[j]]) % TOGGLE]; */
						r[i+j-1] ^= expt[(x = log_pi + log_qj) >= TOGGLE ? x - TOGGLE : x];
					}
				}
			}
		}
		r[0] = p[0] + q[0] - 1;
		/* reduce r mod (x^GF_K + x^GF_T + 1): */
		gf_reduce (r);
	} else {
		/* set r to the null polynomial: */
		r[0] = 0;
	}
	/* destroy potentially sensitive data: */
	x = log_pi = log_qj = 0;
	memset (lg, 0, sizeof (lg));
} /* gf_multiply */


void gf_square (gf_point r, const gf_point p)
	/* sets r := p^2 mod (x^GF_K + x^GF_T + 1) */
{
	int i;
	ltemp x;

	assert (logt != NULL && expt != NULL);
	assert (r != NULL);
	assert (p != NULL);
	if (p[0]) {
		/* in what follows, note that (x != 0) => (x^2 = exp((2 * log(x)) % TOGGLE)): */
		i = p[0];
		if ((x = logt[p[i]]) != TOGGLE) { /* p[i] != 0 */
			r[2*i - 1] = expt[(x += x) >= TOGGLE ? x - TOGGLE : x];
		} else {
			r[2*i - 1] = 0;
		}
		for (i = p[0] - 1; i; i--) {
			r[2*i] = 0;
			if ((x = logt[p[i]]) != TOGGLE) { /* p[i] != 0 */
				r[2*i - 1] = expt[(x += x) >= TOGGLE ? x - TOGGLE : x];
			} else {
				r[2*i - 1] = 0;
			}
		}
		r[0] = 2*p[0] - 1;
		/* reduce r mod (x^GF_K + x^GF_T + 1): */
		gf_reduce (r);
	} else {
		r[0] = 0;
	}
} /* gf_square */


void gf_smalldiv (gf_point p, lunit b)
	/* sets p := (b^(-1))*p mod (x^GF_K + x^GF_T + 1) */
{
	int i;
	ltemp x, lb = logt[b];

	assert (logt != NULL && expt != NULL);
	assert (p != NULL);
	assert (b != 0);
	for (i = p[0]; i; i--) {
		if ((x = logt[p[i]]) != TOGGLE) { /* p[i] != 0 */
			p[i] = expt[(x += TOGGLE - lb) >= TOGGLE ? x - TOGGLE : x];
		}
	}
} /* gf_smalldiv */


static void gf_addmul (gf_point a, ltemp alpha, ltemp j, gf_point b)
{
	ltemp i, x, la = logt[alpha];
	lunit *aj = &a[j];

	assert (logt != NULL && expt != NULL);
	while (a[0] < j + b[0]) {
		a[0]++; a[a[0]] = 0;
	}
	for (i = b[0]; i; i--) {
		if ((x = logt[b[i]]) != TOGGLE) { /* b[i] != 0 */
			aj[i] ^= expt[(x += la) >= TOGGLE ? x - TOGGLE : x];
		}
	}
	while (a[0] && a[a[0]]==0) {
		a[0]--;
	}
} /* gf_addmul */


int gf_invert (gf_point b, const gf_point a)
	/* sets b := a^(-1) mod (x^GF_K + x^GF_T + 1) */
	/* warning: a and b must not overlap! */
{
	gf_point c, f, g;
	ltemp x, j, alpha;

	assert (logt != NULL && expt != NULL);
	assert (b != NULL);
	assert (a != NULL);
	assert (b != a); /* note that this test is not complete */
	if (a[0] == 0) {
		/* a is not invertible */
		return 1;
	}

	/* initialize b := 1; c := 0; f := p; g := x^GF_K + x^GF_T + 1: */
	b[0] = 1; b[1] = 1;
	c[0] = 0;
	gf_copy (f, a);
	gf_clear (g);
	g[0] = GF_K + 1; g[1] = 1; g[GF_T + 1] = 1; g[GF_K + 1] = 1;

	for (;;) {
		if (f[0] == 1) {
			assert (f[1] != 0);
			gf_smalldiv (b, f[1]);
			/* destroy potentially sensitive data: */
			gf_clear (c); gf_clear (f); gf_clear (g); x = j = alpha = 0;
			return 0;
		}
		if (f[0] < g[0]) {
			goto SWAP_FG;
		}
SWAP_GF:
		j = f[0] - g[0];
		x = logt[f[f[0]]] - logt[g[g[0]]] + TOGGLE;
		alpha = expt[x >= TOGGLE ? x - TOGGLE : x];
		gf_addmul (f, alpha, j, g);
		gf_addmul (b, alpha, j, c);
	}

	/* basically same code with b,c,f,g swapped */
	for (;;) {
		if (g[0] == 1) {
			assert (g[1] != 0);
			gf_smalldiv (c, g[1]);
			gf_copy (b, c);
			/* destroy potentially sensitive data: */
			gf_clear (c); gf_clear (f); gf_clear (g); x = j = alpha = 0;
			return 0;
		}
		if (g[0] < f[0]) {
			goto SWAP_GF;
		}
SWAP_FG:
		j = g[0] - f[0];
		x = logt[g[g[0]]] - logt[f[f[0]]] + TOGGLE;
		alpha = expt[x >= TOGGLE ? x - TOGGLE : x];
		gf_addmul (g, alpha, j, f);
		gf_addmul (c, alpha, j, b);
	}
} /* gf_invert */


void gf_squareroot (gf_point p, lunit b)
	/* sets p := sqrt(b) = b^(2^(GF_M-1)) */
{
	int i;
	gf_point q;

	assert (logt != NULL && expt != NULL);
	assert (p != NULL);
	q[0] = 1; q[1] = b;
	if ((GF_M - 1) & 1) {
		/* GF_M - 1 is odd */
		gf_square (p, q);
		i = GF_M - 2;
	} else {
		/* GF_M - 1 is even */
		gf_copy (p, q);
		i = GF_M - 1;
	}
	while (i) {
		gf_square (p, p);
		gf_square (p, p);
		i -= 2;
	}
} /* gf_squareroot */


int gf_trace (const gf_point p)
	/* quickly evaluates to the trace of p (or an error code) */
{
/*
	Let GF(2^m) be considered as a space vector over GF(2).
	The trace function Tr: GF(2^m) -> GF(2) is linear:
	Tr(p + q) = Tr(p) + Tr(q) and Tr(k*p) = k*Tr(p) for k in GF(2).

	Hence, the trace of any field element can be efficiently computed
	if the trace is known for a basis of GF(2^m).

	In other terms, let p(x) = SUM {p_i * x^i} for i = 0...m-1;
	then Tr(p) = SUM {p_i * Tr(x^i)} for i = 0...m-1.

	Surprisingly enough (at least for me :-), it is often the case that
	Tr(p) is simply Tr(p_0) or else Tr(p_0) + Tr(p_(m-1)).

	These properties are exploited in this fast algorithm by George Barwood.
*/

	assert (logt != NULL && expt != NULL);
	assert (p != NULL);
#if (GF_TM0 == 1) && (GF_TM1 == 1)
	/* unit trace mask */
	return p[0] ? p[1] & 1 : 0;
#else
	if (p[0]) {
		int i;
		lunit w;

		w = p[1] & GF_TM1;
#if GF_TM0 != 1
		if (p[0] <= GF_TM0) {
			w ^= p[GF_TM0] & GF_TM2;
		}
#endif /* ?(GF_TM0 != 1) */
		/* compute parity of w: */
		for (i = BITS_PER_LUNIT/2; i > 0; i >>= 1) {
			w ^= w >> i;
		}
		return w & 1;
	} else {
		return 0;
	}
#endif
} /* gf_trace */


int gf_quadsolve (gf_point p, const gf_point beta)
	/* sets p to a solution of p^2 + p = beta */
{
	int i;
#if (GF_M & 1) == 0
	gf_point d, t, nzt;
#endif /* ?((GF_M & 1) == 0) */

	assert (logt != NULL && expt != NULL);
	assert (p != NULL);
	assert (beta != NULL);
	assert (p != beta); /* note that this test is not complete */
	/* check if a solution exists: */
	if (gf_trace (beta) != 0) {
		return 1; /* no solution */
	}
#if (GF_M & 1) == 0
	p[0] = 0;
	gf_copy (d, beta);
	nzt[0] = 1; nzt[1] = GF_NZT; /* field element with nonzero trace */
	assert (gf_trace (nzt) != 0);
	for (i = 1; i < GF_M; i++) {
		gf_square (p, p);
		gf_square (d, d);
		gf_multiply (t, d, nzt);
		gf_add (p, p, t);
		gf_add (d, d, beta);
	}
	/* destroy potentially sensitive information: */
	gf_clear (d);
	gf_clear (t);
#else /* GF_M is odd: compute half-trace */
	gf_copy (p, beta);
	for (i = 0; i < GF_M/2; i++) {
		gf_square (p, p);
		gf_square (p, p);
		gf_add (p, p, beta);
	}
#endif /* ?((GF_M & 1) == 0) */
	return 0;
} /* gf_quadsolve */


int gf_ybit (const gf_point p)
	/* evaluates to the rightmost (least significant) bit of p (or an error code) */
{
	assert (p != NULL);
	return p[0] ? (int) (p[1] & 1) : 0;
} /* gf_ybit */


void gf_pack (const gf_point p, vl_point k)
	/* packs a field point into a vl_point */
{
	int i;
	vl_point a;

	assert (p != NULL);
	assert (k != NULL);
	vl_clear (k); a[0] = 1;
	for (i = p[0]; i > 0; i--) {
		vl_shortlshift (k, GF_L); /* this only works if GF_L <= 16 */
		a[1] = p[i];
		vl_add (k, a);
	}
} /* gf_pack */


void gf_unpack (gf_point p, const vl_point k)
	/* unpacks a vl_point into a field point */
{
	vl_point x;
	lunit n;

	assert (p != NULL);
	assert (k != NULL);
	vl_copy (x, k);
	for (n = 0; x[0]; n++) {
		p[n+1] = (lunit) (x[1] & TOGGLE);
		vl_shortrshift (x, GF_L); /* this only works if GF_L <= 16 */
	}
	p[0] = n;
} /* gf_unpack */
